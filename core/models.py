"""
Core data models using Pydantic for validation.
These models represent the domain entities for the trading system.
"""
from datetime import datetime
from enum import Enum
from typing import Optional, List
from pydantic import BaseModel, Field
from decimal import Decimal


class MatchStatus(str, Enum):
    """Status of a football match."""
    NOT_STARTED = "NOT_STARTED"
    FIRST_HALF = "1H"
    HALFTIME = "HT"
    SECOND_HALF = "2H"
    EXTRA_TIME = "ET"
    PENALTIES = "PEN"
    FINISHED = "FT"
    SUSPENDED = "SUSP"
    POSTPONED = "PST"
    CANCELLED = "CANC"
    ABANDONED = "ABD"
    LIVE = "LIVE"


class OrderSide(str, Enum):
    """Order side for trading."""
    BUY = "buy"
    SELL = "sell"


class OrderStatus(str, Enum):
    """Status of an order."""
    PENDING = "pending"
    SUBMITTED = "submitted"
    FILLED = "filled"
    PARTIALLY_FILLED = "partial"
    CANCELLED = "cancelled"
    REJECTED = "rejected"
    EXPIRED = "expired"


class PositionStatus(str, Enum):
    """Status of a position."""
    OPEN = "open"
    CLOSED = "closed"


class Team(BaseModel):
    """Football team information."""
    id: int
    name: str
    logo: Optional[str] = None
    
    def normalized_name(self) -> str:
        """Return normalized team name for matching."""
        return self.name.lower().strip().replace(" fc", "").replace(" cf", "")


class Match(BaseModel):
    """Football match information."""
    id: int
    league_id: int
    league_name: str
    home_team: Team
    away_team: Team
    home_score: int = 0
    away_score: int = 0
    status: MatchStatus = MatchStatus.NOT_STARTED
    minute: Optional[int] = None
    kickoff: datetime
    venue: Optional[str] = None
    
    @property
    def display_name(self) -> str:
        return f"{self.home_team.name} vs {self.away_team.name}"


class GoalEvent(BaseModel):
    """A goal event detected from live scores."""
    model_config = {"frozen": True}  # Make hashable for deduplication
    
    id: str = Field(description="Unique event ID")
    match_id: int
    timestamp: datetime
    minute: int
    scoring_team_id: int
    scoring_team_name: str
    is_home_team: bool
    home_score: int
    away_score: int
    player_name: Optional[str] = None


class Market(BaseModel):
    """Exchange market information."""
    id: str = Field(description="Exchange market ID")
    exchange: str = Field(description="Exchange name (kalshi, polymarket)")
    title: str
    subtitle: Optional[str] = None
    event_ticker: Optional[str] = None
    yes_price: float = Field(ge=0, le=1, description="Price for YES outcome (0-1)")
    no_price: float = Field(ge=0, le=1, description="Price for NO outcome (0-1)")
    yes_volume: float = 0
    no_volume: float = 0
    open_interest: float = 0
    status: str = "open"
    expiration: Optional[datetime] = None
    
    @property
    def implied_probability_yes(self) -> float:
        """Implied probability from YES price."""
        return self.yes_price
    
    @property
    def implied_probability_no(self) -> float:
        """Implied probability from NO price."""
        return self.no_price


class MatchMarketMapping(BaseModel):
    """Maps a football match to exchange markets."""
    match_id: int
    home_team_name: str
    away_team_name: str
    league_name: str
    kickoff: datetime
    markets: List[Market] = []
    pre_goal_home_prob: Optional[float] = None
    pre_goal_away_prob: Optional[float] = None
    last_updated: datetime = Field(default_factory=datetime.utcnow)


class OrderIntent(BaseModel):
    """Intent to place an order - generated by decision engine."""
    id: str = Field(description="Unique intent ID")
    match_id: int
    market_id: str
    exchange: str
    side: OrderSide
    outcome: str = Field(description="YES or NO")
    size: float = Field(ge=0, description="Order size in dollars (0 = to be set by risk manager)")
    limit_price: float = Field(ge=0, le=1, description="Limit price (0-1)")
    reason: str = Field(description="Why this trade was generated")
    goal_event_id: str
    created_at: datetime = Field(default_factory=datetime.utcnow)


class Order(BaseModel):
    """An order submitted to an exchange."""
    id: str = Field(description="Internal order ID")
    exchange_order_id: Optional[str] = None
    intent_id: str
    match_id: int
    market_id: str
    exchange: str
    side: OrderSide
    outcome: str
    size: float
    limit_price: float
    filled_size: float = 0
    avg_fill_price: Optional[float] = None
    status: OrderStatus = OrderStatus.PENDING
    submitted_at: Optional[datetime] = None
    filled_at: Optional[datetime] = None
    error_message: Optional[str] = None


class Position(BaseModel):
    """An open or closed position."""
    id: str
    match_id: int
    market_id: str
    exchange: str
    outcome: str
    size: float
    entry_price: float
    current_price: float
    unrealized_pnl: float = 0
    realized_pnl: float = 0
    status: PositionStatus = PositionStatus.OPEN
    opened_at: datetime
    closed_at: Optional[datetime] = None
    entry_order_id: str
    exit_order_id: Optional[str] = None


class Trade(BaseModel):
    """A completed trade (entry + exit)."""
    id: str
    match_id: int
    match_name: str
    market_id: str
    exchange: str
    outcome: str
    entry_price: float
    exit_price: Optional[float] = None
    size: float
    pnl: float = 0
    pnl_pct: float = 0
    entry_time: datetime
    exit_time: Optional[datetime] = None
    goal_event_id: str
    reason: str


class TradingMetrics(BaseModel):
    """Aggregated trading metrics."""
    total_trades: int = 0
    winning_trades: int = 0
    losing_trades: int = 0
    win_rate: float = 0
    total_pnl: float = 0
    avg_pnl_per_trade: float = 0
    avg_latency_ms: float = 0
    max_latency_ms: float = 0
    avg_slippage: float = 0
    daily_pnl: float = 0
    open_positions: int = 0
    total_exposure: float = 0


class RiskStatus(BaseModel):
    """Current risk management status."""
    daily_pnl: float = 0
    daily_loss_limit: float
    daily_loss_remaining: float
    current_exposure: float = 0
    max_exposure: float
    consecutive_errors: int = 0
    circuit_breaker_active: bool = False
    last_error: Optional[str] = None


# NFL-specific models

class NFLGameStatus(str, Enum):
    """Status of an NFL game."""
    SCHEDULED = "SCHEDULED"
    FIRST_QUARTER = "Q1"
    SECOND_QUARTER = "Q2"
    HALFTIME = "HT"
    THIRD_QUARTER = "Q3"
    FOURTH_QUARTER = "Q4"
    OVERTIME = "OT"
    IN_PROGRESS = "IN_PROGRESS"
    FINAL = "FINAL"
    POSTPONED = "POSTPONED"
    CANCELLED = "CANCELLED"


class NFLTeam(BaseModel):
    """NFL team information."""
    id: int
    name: str
    abbreviation: str = ""
    logo: Optional[str] = None
    
    def normalized_name(self) -> str:
        """Return normalized team name for matching."""
        return self.name.lower().strip()


class NFLGame(BaseModel):
    """NFL game information."""
    id: int
    home_team: NFLTeam
    away_team: NFLTeam
    home_score: int = 0
    away_score: int = 0
    status: NFLGameStatus = NFLGameStatus.SCHEDULED
    quarter: int = 0
    clock: str = "15:00"
    kickoff: datetime
    venue: Optional[str] = None
    spread: Optional[float] = None  # Negative = home favored
    over_under: Optional[float] = None
    week: Optional[int] = None
    
    @property
    def display_name(self) -> str:
        return f"{self.away_team.name} @ {self.home_team.name}"
    
    @property
    def is_live(self) -> bool:
        return self.status in (
            NFLGameStatus.FIRST_QUARTER,
            NFLGameStatus.SECOND_QUARTER,
            NFLGameStatus.THIRD_QUARTER,
            NFLGameStatus.FOURTH_QUARTER,
            NFLGameStatus.OVERTIME,
            NFLGameStatus.IN_PROGRESS
        )


class NFLScoringEvent(BaseModel):
    """A scoring event detected from live NFL scores."""
    model_config = {"frozen": True}
    
    id: str = Field(description="Unique event ID")
    game_id: int
    timestamp: datetime
    quarter: int
    clock: str
    scoring_team_id: int
    scoring_team_name: str
    is_home_team: bool
    points_scored: int
    scoring_type: str  # touchdown, field_goal, safety, etc.
    home_score: int
    away_score: int


class NFLGameMarketMapping(BaseModel):
    """Maps an NFL game to exchange markets."""
    game_id: int
    home_team_name: str
    away_team_name: str
    kickoff: datetime
    markets: List[Market] = []
    pre_score_home_prob: Optional[float] = None
    pre_score_away_prob: Optional[float] = None
    spread: Optional[float] = None
    over_under: Optional[float] = None
    last_updated: datetime = Field(default_factory=datetime.utcnow)
